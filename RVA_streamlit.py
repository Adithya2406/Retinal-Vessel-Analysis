import streamlit as st

def main():
    st.title("Retinal Vessel Analysis")

    # Upload image file
    uploaded_file = st.file_uploader("Upload an image", type=["jpg", "jpeg", "png", "tif"])
    
    if uploaded_file is not None:
        # Display uploaded image
        st.image(uploaded_file, caption='Uploaded Image', use_column_width=True)

        
        
        if st.button("Execute Code"):
            try:
            
            
                # -*- coding: utf-8 -*-
                #Retinal Vessel Analysis

                #Automatically generated by Colab.

                #Original file is located at
                #    https://colab.research.google.com/drive/1EehsT8OIuApaYru7rSgd2rRdD6yZETD8
                #

                import cv2
                import numpy as np
                from math import sqrt
                from skimage.transform import hough_ellipse
                from skimage.draw import ellipse_perimeter
                from skimage.feature import canny
                import matplotlib.pyplot as plt


                #Loading H5 model for prepocessing the data. 3 layers CNN model"""

                from keras.models import Sequential
                import cv2
                import numpy as np
                from tensorflow.keras.models import load_model

                model = load_model(r'HRDv9.h5')

                input_path = uploaded_file.name

                import re

                string_with_numbers = input_path
                numbers = re.findall(r'\d+', string_with_numbers)
                numbers = [int(num) for num in numbers]

                for i in numbers:
                    patient_number = i
                print(patient_number)

                img = cv2.imread(input_path)
                R,G,B = cv2.split(img)
                img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
                plt.imshow(img)
                plt.show()

                #CLAHE Algorithm to improve image contrast."""

                clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
                img_clahe = clahe.apply(img[:,:,1])
                plt.imshow(G)
                plt.show()
                plt.imshow(img_clahe)
                plt.show()

                #Blurring the image using mean filter."""

                kernel = np.ones((31,31))/961
                imgavg = cv2.filter2D(img_clahe,-1,kernel)
                plt.imshow(imgavg)
                plt.show()

                #Performing histogram calculation, finding the maximum value"""

                hist = cv2.calcHist([img_clahe],[0],None,[256],[0,256])
                maxVal = -1
                maxLoc = [(0,0)]
                for x in range(imgavg.shape[0]):
                    for y in range(imgavg.shape[1]):
                        #print(x,y)
                        if imgavg[x][y] >= maxVal:
                            maxVal = imgavg[x][y]
                            maxLoc[0] = (y,x)
                print(maxLoc)
                loc = len(maxLoc)
                imgtemp = imgavg.copy()
                print(imgavg[maxLoc[0][1]][maxLoc[0][0]])
                cv2.circle(imgtemp,maxLoc[loc-1],5,(0),-1)
                plt.imshow(imgavg)
                plt.show()

                #Getting max value below the threshold point"""

                thresh, imgthresh = cv2.threshold(imgavg,180,255,cv2.THRESH_BINARY)
                plt.imshow(imgthresh)
                plt.show()

                #Finding Contours.

                #Contours - continuous points with same intensity or color
                

                contours,hierarchy = cv2.findContours(imgthresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)
                #print(contours)
                cv2.drawContours(img_clahe, contours, contourIdx=-1, color=0, thickness=1)
                plt.imshow(img_clahe)
                plt.show()

                #Detecting ROI"""

                length = len(contours[0])
                radius = 0
                for i in range(length):
                    radius = radius + sqrt((contours[0][i][0][0]-maxLoc[0][0])**2 + (contours[0][i][0][0]-maxLoc[0][0])**2)
                radius = int(radius/length)
                print(radius)
                imgtemp2 = imgavg.copy()
                cv2.circle(imgtemp2,maxLoc[loc-1],int(radius),(0),2)
                plt.imshow(imgtemp2)
                plt.show()
                #cv2.imwrite(r'/content/Rditect.jpg',imgtemp2)

                #Masking ROI"""

                ROIrad = radius*4
                mask = np.zeros((imgthresh.shape[0],imgthresh.shape[1]), dtype=np.uint8)
                cv2.circle(mask,maxLoc[loc-1],ROIrad,(255),-1)
                plt.imshow(mask)
                plt.show()
                #cv2.imwrite(r'/content/imagesROIi.jpg',mask)

                #Visualizing ROI where mask is non zero"""

                img_roi = cv2.bitwise_and(img, img, mask=mask)
                plt.imshow(img_roi)
                plt.show()

                #Images are divided into 27*27 pixels in one patch."""

                import numpy as np

                patch_size = 27
                patches = []
                patches_copy = []
                for i in range(0, img_clahe.shape[0]-patch_size, patch_size):
                    for j in range(0, img_clahe.shape[1]-patch_size, patch_size):
                        patch = img_clahe[i:i+patch_size, j:j+patch_size]
                        patch = patch.reshape((patch_size, patch_size, 1))
                        patches.append(patch)
                        patches_copy.append(patch)
                patches = np.array(patches)
                patches = patches.astype('float32') / 255.0
                predictions = model.predict(patches)
                vessel_patches_copy = []
                for i, patch in enumerate(patches_copy):
                    if np.max(predictions[i]) == 1.0:
                        patch = patch.reshape((patch_size, patch_size))
                        vessel_patches_copy.append(patch)
                vessel_patches = np.array(vessel_patches_copy)
                vessel_patches = vessel_patches.astype('float32') / 255.0

                print(patch.shape)
                print(len(patches))
                print(len(vessel_patches_copy))
                print(len(vessel_patches))

                #Classification of patched based on presence of vessels"""

                import numpy as np
                patch_size=27
                binary_image = np.zeros_like(img_clahe)
                test= np.zeros_like(img_roi)
                idx = 0
                for i in range(0, img_clahe.shape[0]-patch_size, patch_size):
                    for j in range(0, img_clahe.shape[1]-patch_size, patch_size):
                        if predictions[idx][1] > predictions[idx][0]:
                            binary_image[i:i+patch_size, j:j+patch_size] = 255
                        idx += 1

                print(binary_image.shape)

                #Morphological closing for vessel segmentation"""

                kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))
                binary_image = cv2.morphologyEx(binary_image, cv2.MORPH_CLOSE, kernel)
                plt.imshow(binary_image)
                #cv2.imwrite(r'/content/imagestt1.tiff',binary_image)
                plt.show()

                #Visualization of the vessel segmentation by superimposing with the original image"""

                overlay = cv2.addWeighted(img, 0.5, cv2.cvtColor(binary_image, cv2.COLOR_GRAY2BGR), 0.5, 0)
                plt.imshow(overlay)
                #cv2.imwrite(r'/content/imagestt11.tiff',overlay)
                plt.show()
                print(overlay.shape)

                import cv2
                import numpy as np
                from math import sqrt
                import matplotlib.pyplot as plt
                r,imageGreen,b = cv2.split(img)
                plt.imshow(imageGreen)
                plt.show()
                #cv2.imwrite(r'/content/imagesgreenchannel.tiff',imageGreen)
                plt.imshow(r)
                plt.show()
                plt.imshow(b)
                plt.show()
                plt.imshow( cv2.cvtColor(img,cv2.COLOR_BGR2GRAY))
                plt.show()

                #Enhancing the quality of features by improving contrast of the image using CLAHE"""

                clahe = cv2.createCLAHE(clipLimit = 2.0, tileGridSize = (8,8))
                imageEqualized = clahe.apply(imageGreen)
                plt.imshow(imageEqualized)
                plt.show()
                #cv2.imwrite(r'/content/imagesequalized.tiff',imageEqualized)

                #Increasing the contrast by inverting the image"""

                imageInv2 = 255 - imageEqualized
                imageInv = clahe.apply(imageInv2)
                plt.imshow(imageInv)
                plt.show()
                #cv2.imwrite(r'/content/imagesinverted.tiff',imageInv)

                #Blood Vessel Segmentation"""

                import cv2
                import numpy as np
                import os
                import csv
                import matplotlib.pyplot as plt


                def extract_bv(image):
                    b,green_fundus,r = cv2.split(image)
                    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
                    contrast_enhanced_green_fundus = clahe.apply(green_fundus)
                    r1 = cv2.morphologyEx(contrast_enhanced_green_fundus, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5)), iterations = 1)
                    R1 = cv2.morphologyEx(r1, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(5,5)), iterations = 1)
                    r2 = cv2.morphologyEx(R1, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(11,11)), iterations = 1)
                    R2 = cv2.morphologyEx(r2, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(11,11)), iterations = 1)
                    r3 = cv2.morphologyEx(R2, cv2.MORPH_OPEN, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(23,23)), iterations = 1)
                    R3 = cv2.morphologyEx(r3, cv2.MORPH_CLOSE, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(23,23)), iterations = 1)
                    f4 = cv2.subtract(R3,contrast_enhanced_green_fundus)
                    f5 = clahe.apply(f4)
                    ret,f6 = cv2.threshold(f5,15,255,cv2.THRESH_BINARY)
                    mask = np.ones(f5.shape[:2], dtype="uint8") * 255
                    contours, hierarchy = cv2.findContours(f6.copy(),cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)
                    for cnt in contours:
                        if cv2.contourArea(cnt) <= 200:
                            cv2.drawContours(mask, [cnt], -1, 0, -1)
                    im = cv2.bitwise_and(f5, f5, mask=mask)
                    ret,fin = cv2.threshold(im,15,255,cv2.THRESH_BINARY_INV)
                    newfin = cv2.erode(fin, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(3,3)), iterations=1)
                    fundus_eroded = cv2.bitwise_not(newfin)
                    xmask = np.ones(fundus.shape[:2], dtype="uint8") * 255
                    xcontours, xhierarchy = cv2.findContours(fundus_eroded.copy(),cv2.RETR_LIST,cv2.CHAIN_APPROX_SIMPLE)
                    for cnt in xcontours:
                        shape = "unidentified"
                        peri = cv2.arcLength(cnt, True)
                        approx = cv2.approxPolyDP(cnt, 0.04 * peri, False)
                        if len(approx) > 4 and cv2.contourArea(cnt) <= 3000 and cv2.contourArea(cnt) >= 100:
                            shape = "circle"
                        else:
                            shape = "veins"
                        if(shape=="circle"):
                            cv2.drawContours(xmask, [cnt], -1, 0, -1)
                    finimage = cv2.bitwise_and(fundus_eroded,fundus_eroded,mask=xmask)
                    blood_vessels = cv2.bitwise_not(finimage)
                    return blood_vessels
                if __name__ == "__main__":
                    fundus = cv2.imread(input_path, cv2.IMREAD_COLOR)
                    bloodvessel = extract_bv(fundus)
                    cv2.imwrite(r"/content/imagesbloodvessel.tiff",bloodvessel)
                #     plt.imshow(fundus, cmap='gray')
                #     plt.show()
                    plt.imshow(bloodvessel, cmap='binary')
                    plt.show()

                img = cv2.imread(r'/content/imagesbloodvessel.tiff', cv2.IMREAD_GRAYSCALE)
                unique_values = np.unique(img)
                print(unique_values)
                if len(unique_values) == 2:
                    print("The image is binary .")
                else:
                    print("The image is not binary.")

                #Segmenting arteries and veins based on their mean intensity compared to the given mask."""

                import cv2
                import numpy as np

                img = overlay
                b, g, r = cv2.split(img)
                mean_intensity = np.mean(g[mask > 0])
                artery_mask = np.logical_and(mask, g > mean_intensity)
                vein_mask = np.logical_and(mask, g <= mean_intensity)
                #cv2.imwrite(r'/content/imagesartery_mask.tiff', artery_mask.astype(np.uint8) * 255)
                #cv2.imwrite(r'/content/imagesvein_mask.tiff', vein_mask.astype(np.uint8) * 255)

                #Computing distance transform of the artery and vein masks"""

                arteryDist = cv2.distanceTransform( artery_mask.astype(np.uint8) * 255,cv2.DIST_L1, cv2.DIST_MASK_PRECISE)
                veinDist = cv2.distanceTransform( vein_mask.astype(np.uint8) * 255,cv2.DIST_L1, cv2.DIST_MASK_PRECISE)
                print(len(arteryDist))
                print(len(veinDist))
                plt.imshow(arteryDist)
                plt.show()
                plt.imshow(veinDist)
                plt.show()
                #cv2.imwrite(r'/content/imagesveinDistmet2.tiff', veinDist)
                #cv2.imwrite(r'/content/imagesarteryDistmet2.tiff', arteryDist)

                #Calculating CRVE and CRAE;
                #CRAE - central retinal arteriolar equivalent;
                #CRVE - central retinal venular equivalent
                

                venuole = []
                arteriole = []
                for x in range(veinDist.shape[0]):
                    for y in range(veinDist.shape[1]):
                        if veinDist[x][y] > 0:
                            venuole.append(veinDist[x][y])
                        if arteryDist[x][y] > 0:
                            arteriole.append(arteryDist[x][y])

                venuole = sorted(venuole)
                arteriole = sorted(arteriole)

                lenven = len(venuole)
                print('length of lenven {} {} {}'.format(lenven,lenven//2,lenven//2-1))
                if lenven%2 == 1:
                    Wa = venuole[lenven//2]
                    if lenven//2 == 0:
                        Wb = venuole[0]
                    else:
                        Wb = venuole[lenven//2 - 1]
                else:
                    Wa = (venuole[lenven//2 - 1] + venuole[lenven//2])// 2
                    Wb = venuole[lenven//2 - 1]
                print(Wa,Wb)
                CRVE = sqrt(0.72*(Wa**2) + 0.91*(Wb**2) + 450.02)
                lenart = len(arteriole)

                if lenart%2 == 1:
                    Wa = arteriole[lenart//2]
                    if lenart//2 == 0:
                        Wb = arteriole[0]
                    else:
                        Wb = arteriole[lenart//2 - 1]
                else:
                    Wa = (arteriole[lenart//2 - 1] + arteriole[lenart//2])// 2
                    Wb = arteriole[lenart//2 - 1]
                print(arteriole)
                print(Wa,Wb)
                CRAE = sqrt(0.87*(Wa**2) + 1.01*(Wb**2) - .22*Wa*Wb - 10.73)

                artervenratio = CRAE/CRVE
                print('arteriovenous ratio {}'.format(artervenratio))

                venuole = []
                arteriole = []
                for x in range(veinDist.shape[0]):
                    for y in range( veinDist.shape[1]):
                        if  veinDist[x][y] > 0:
                            venuole.append(abs( veinDist[x][y]))
                        if arteryDist[x][y] > 0:
                            arteriole.append(abs(arteryDist[x][y]))

                venuole = sorted(venuole)
                arteriole = sorted(arteriole)
                print("venuole=",venuole)
                print("arteriole",arteriole)
                lenven = len(venuole)
                print('length of lenven {} {} {}'.format(lenven,lenven//2,lenven//2-1))
                if lenven%2 == 1:
                    Wa = venuole[lenven//2]
                    if lenven//2 == 0:
                        Wb = venuole[0]
                    else:
                        Wb = venuole[lenven//2 - 1]
                else:
                    Wa = (venuole[lenven//2 - 1] + venuole[lenven//2])// 2
                    Wb = venuole[lenven//2 - 1]
                #print(Wa,Wb)
                CRVE = sqrt(0.72*(Wa**2) + 0.91*(Wb**2) + 450.02)
                print("CRVE=",CRVE)
                lenart = len(arteriole)
                print('length of lenart {} {} {}'.format(lenart,lenart//2,lenart//2-1))
                if lenart%2 == 1:
                    Wa = arteriole[lenart//2]
                    if lenart//2 == 0:
                        Wb = arteriole[0]
                    else:
                        Wb = arteriole[lenart//2 - 1]
                else:
                    Wa = (arteriole[lenart//2 - 1] + arteriole[lenart//2])// 2
                    Wb = arteriole[lenart//2 - 1]

                #print(Wa,Wb)
                CRAE = sqrt(0.8*(Wa**2) + 1.01*(Wb**2) - 0.22*Wa*Wb-10.73)
                print("CRAE=",CRAE)

                avr = CRAE/CRVE
                print(avr)

                #Calculating AVR ratio"""

                import cv2
                import numpy as np

                threshold = 2.25 # in mm
                artery_thicknesses = []
                vein_thicknesses = []
                for i in range(len(vessel_patches_copy)):
                    vessel_patch = vessel_patches_copy[i]
                    if np.all(vessel_patch == 0):
                        print('Patch', i+1, 'is completely black. There are no veins or arteries detected ')
                        continue
                    elif np.all(vessel_patch == 255):#image blanche
                        print('Patch', i+1, 'is completely white. There are no veins or arteries detected ')
                        continue

                    ret, thresh = cv2.threshold(vessel_patch, 127, 255, cv2.THRESH_BINARY)
                    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
                    thicknesses = []
                    for c in contours:
                        perimeter = cv2.arcLength(c, True)
                        if perimeter > 0:
                            area = cv2.contourArea(c)
                            thickness = area / perimeter
                            thicknesses.append(thickness)
                    arteries = 0
                    veins = 0
                    for t in thicknesses:
                        if t > threshold:
                            arteries += 1
                            artery_thicknesses.append(t)
                        else:
                            veins += 1
                            vein_thicknesses.append(t)
                #     print('Patch', i+1)
                #     print('Arteries:', arteries)
                #     print('Veins:', veins)
                print("Number of arteries detected =",len(artery_thicknesses))
                print("Number of veins detected =",len(vein_thicknesses))
                a=0
                MA=0
                for i in  range(len(artery_thicknesses)):
                    a+=artery_thicknesses[i]
                MA=a/(len(artery_thicknesses))
                print("Sum of thickness of all arteries =",a)
                print("Total length of all arteries =",len(artery_thicknesses))
                b=0
                MV=0
                for j in  range(len(vein_thicknesses)):
                    b+=vein_thicknesses[j]
                MV=b/len(vein_thicknesses)
                print("Sum of thickness of all veins =",b)
                print("Total length of all veins =",len(vein_thicknesses))
                AVR= a/b
                print("Arteriovenous Ratio (AVR) = ",AVR)

                if AVR > 0.9:
                    grade = 1
                elif 0.8 < AVR <= 0.9:
                    grade = 2
                elif 0.7 <= AVR <= 0.8:
                    grade = 0
                elif 0.6 < AVR < 0.7:
                    grade = 3
                elif AVR <= 0.6:
                    grade = 4

                test_list = [patient_number,CRVE,CRAE,AVR,len(artery_thicknesses),len(vein_thicknesses),a,len(artery_thicknesses),b,len(vein_thicknesses),grade]
                
                
                st.write("Feature List:\n 0-Patient Number \n 1-CRVE \n 2-CRAE \n 3-AVR 4-No. of Arteries \n 5-No. of Veins \n 6-sum of thickness of all arteries \n 7-total length of arteries \n 8-sum of thickness of all veins 9-total length of all veins \n 10-Grade \n 11-Exudates")
                
                
                #st.write(test_list)

                import cv2
                import numpy as np
                import matplotlib.pyplot as plt

                values = [CRVE, CRAE, AVR, int(a), len(artery_thicknesses), int(b), len(vein_thicknesses)]
                labels = ['CRVE (mm)', 'CRAE (mm)', 'AVR', 'Sum of Artery Thickness (mm)', 'Total Arteries',
                        'Sum of Vein Thickness (mm)', 'Total Veins']

                plt.figure(figsize=(20, 7))
                plt.bar(labels, values, color=['blue', 'green', 'black', 'orange', 'purple', 'skyblue', 'grey'])

                plt.xlabel('Features Extratced')
                plt.ylabel('Values of the extracted features')
                plt.title('Values of Features Extracted')
                plt.xticks(rotation=45)
                plt.show()

                #Finding Presence of exudates

                

                import numpy as np
                import cv2 as cv
                from skimage import morphology

                class ExtractBloodVessels:
                    image = 0

                    def readImage(self, img):
                        self.image = np.array(img)
                        return self.image

                    def greenComp(self, image):
                        gcImg = self.image[:, :, 1]
                        self.image = gcImg
                        return self.image

                    def histEqualize(self, image):
                        histEqImg = cv.equalizeHist(self.image)
                        self.image = histEqImg
                        return self.image

                    def kirschFilter(self, image):
                        gray = self.image
                        if gray.ndim > 2:
                            raise Exception("illegal argument: input must be a single channel image (gray)")
                        kernelG1 = np.array([[5, 5, 5],
                                            [-3, 0, -3],
                                            [-3, -3, -3]], dtype=np.float32)
                        kernelG2 = np.array([[5, 5, -3],
                                            [5, 0, -3],
                                            [-3, -3, -3]], dtype=np.float32)
                        kernelG3 = np.array([[5, -3, -3],
                                            [5, 0, -3],
                                            [5, -3, -3]], dtype=np.float32)
                        kernelG4 = np.array([[-3, -3, -3],
                                            [5, 0, -3],
                                            [5, 5, -3]], dtype=np.float32)
                        kernelG5 = np.array([[-3, -3, -3],
                                            [-3, 0, -3],
                                            [5, 5, 5]], dtype=np.float32)
                        kernelG6 = np.array([[-3, -3, -3],
                                            [-3, 0, 5],
                                            [-3, 5, 5]], dtype=np.float32)
                        kernelG7 = np.array([[-3, -3, 5],
                                            [-3, 0, 5],
                                            [-3, -3, 5]], dtype=np.float32)
                        kernelG8 = np.array([[-3, 5, 5],
                                            [-3, 0, 5],
                                            [-3, -3, -3]], dtype=np.float32)

                        g1 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG1), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        g2 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG2), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        g3 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG3), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        g4 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG4), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        g5 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG5), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        g6 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG6), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        g7 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG7), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        g8 = cv.normalize(cv.filter2D(gray, cv.CV_32F, kernelG8), None, 0, 255, cv.NORM_MINMAX, cv.CV_8UC1)
                        magn = cv.max(g1, cv.max(g2, cv.max(g3, cv.max(g4, cv.max(g5, cv.max(g6, cv.max(g7, g8)))))))
                        self.image = magn
                        return self.image

                    def threshold(self, image):
                        ret, threshImg = cv.threshold(self.image, 160, 180, cv.THRESH_BINARY_INV)
                        self.image = threshImg
                        return self.image

                    def clearSmallObjects(self, image):
                        cleanImg = morphology.remove_small_objects(self.image, min_size=130, connectivity=100)
                        self.image = cleanImg
                        return self.image

                class ExtractExudates:
                    image = 0

                    def readImage(self, img):
                        self.image = np.array(img)
                        return self.image

                    def greenComp(self, image):
                        gcImg = image[:, :, 1]
                        image = gcImg
                        return image

                    def CLAHE(self, image):
                        clahe = cv.createCLAHE()
                        clImg = clahe.apply(image)
                        image = clImg
                        return image

                    def dilation(self, image):
                        strEl = cv.getStructuringElement(cv.MORPH_ELLIPSE, (6, 6))
                        dilateImg = cv.dilate(image, strEl)
                        image = dilateImg
                        return image

                    def threshold(self, image):
                        retValue, threshImg = cv.threshold(image, 254, 255, cv.THRESH_BINARY)
                        image = threshImg
                        return image

                    def medianFilter(self, image):
                        medianImg = cv.medianBlur(image, 5)
                        image = medianImg
                        return image

                # Define the input image filenames
                vessels_image_filename = input_path
                exudates_image_filename = input_path

                # Blood Vessels Extraction
                if os.path.isfile(vessels_image_filename):
                    # Extraction of Blood vessels
                    vessels = ExtractBloodVessels()
                    image = cv.imread(vessels_image_filename, 1)
                    convNp = vessels.readImage(image)
                    gComponent = vessels.greenComp(convNp)
                    histEqualize = vessels.histEqualize(gComponent)
                    kirschFilter = vessels.kirschFilter(histEqualize)
                    thresh = vessels.threshold(kirschFilter)
                    vesselsImage = vessels.clearSmallObjects(thresh)
                    result = vessels_image_filename.rsplit('.', maxsplit=1)
                    cv.imwrite(str(result[0]) + 'Vessels.' + str(result[1]), vesselsImage)
                    print("Blood Vessels Extraction Done!")
                else:
                    print("Blood Vessels Extraction Failed! - Image doesn't exist")

                # Exudates Extraction
                if os.path.isfile(exudates_image_filename):
                    # Extraction of exudates
                    exudates = ExtractExudates()
                    image = cv.imread(exudates_image_filename, 1)
                    convNp = exudates.readImage(image)
                    gComponent = exudates.greenComp(convNp)
                    clahe = exudates.CLAHE(gComponent)
                    dilate = exudates.dilation(clahe)
                    thresh = exudates.threshold(dilate)
                    exudatesImage = exudates.medianFilter(thresh)
                    result = exudates_image_filename.rsplit('.', maxsplit=1)
                    cv.imwrite(str(result[0]) + 'Exudates.' + str(result[1]), exudatesImage)
                    print("Exudates Extraction Done!")

                #Checking the Percentage Value of Exudates

                #



                input_image_exudates = input_path[:-4]+'Exudates.tif'
                print(input_image_exudates)

                def check_percentage_of_white_pixels(input_image_exudates):
                    # Count the total number of pixels
                    total_pixels = binary_image.size

                    # Count the number of white pixels
                    white_pixels = np.sum(binary_image == 255)

                    # Calculate the percentage of white pixels
                    white_pixel_percentage = (white_pixels / total_pixels) * 100
                    print(white_pixel_percentage)

                    # Check if the percentage of white pixels is greater than 10
                    if white_pixel_percentage > 40:
                        return 1
                    else:
                        return 0

                # Assuming 'binary_image' is your binary image
                result = check_percentage_of_white_pixels(input_image_exudates)
                print("Result:", result)


                test_list.append(result)
                print(test_list)
                st.write(test_list)

                #Loading the .csv dataset"""

                import pandas as pd
                import matplotlib.pyplot as plt

                # Load data from CSV file
                data = pd.read_csv('eye.csv')

                # Plotting
                plt.figure(figsize=(10, 6))
                plt.scatter(data.index, data['grade'], color='red', alpha=0.5)
                plt.title('Stages of Hypertensive Retinopathy among various patients in our dataset')
                plt.xlabel('Patient Number')
                plt.ylabel('Stage of Hypertensive Retinopathy')
                plt.yticks(range(5))
                plt.grid(True)
                plt.show()

                import pandas as pd
                import matplotlib.pyplot as plt

                # Plotting
                plt.figure(figsize=(10, 6))
                plt.scatter(data.index, data['exudates'], color='blue', alpha=0.5)
                plt.title('Exudate Distribution among various patients in our dataset')
                plt.xlabel('Patient Number')
                plt.ylabel('Exudates (0 - Absence of exudate, 1 - Present of exudate)')
                plt.grid(True)
                plt.show()

                import pandas as pd
                from sklearn.model_selection import train_test_split
                from sklearn.preprocessing import StandardScaler
                from sklearn.metrics import accuracy_score, precision_score, recall_score, classification_report
                from sklearn.linear_model import LogisticRegression
                from sklearn.neighbors import KNeighborsClassifier
                from sklearn.svm import SVC
                from sklearn.tree import DecisionTreeClassifier
                from sklearn.ensemble import RandomForestClassifier
                import matplotlib.pyplot as plt

                # Load your dataset (replace 'your_data.csv' with the actual path)
                data = pd.read_csv('eye.csv')

                # Define the target variable
                target_variable = 'target'  # Replace with the name of your target column

                # Separate features and target
                X = data.drop(target_variable, axis=1)
                y = data[target_variable]

                # Split data into training and testing sets (adjust test_size as needed)
                X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

                # Standardize features (if necessary for your models)
                scaler = StandardScaler()
                X_train = scaler.fit_transform(X_train)
                X_test = scaler.transform(X_test)

                # Define and train multiple classification models
                models = {
                    'Logistic Regression': LogisticRegression(multi_class='ovr', solver='lbfgs'),
                    'K-Nearest Neighbors': KNeighborsClassifier(n_neighbors=5),
                    'Support Vector Machine (SVM)': SVC(kernel='linear'),
                    'Decision Tree': DecisionTreeClassifier(),
                }

                # Train each model
                for name, model in models.items():
                    model.fit(X_train, y_train)

                # Evaluate model performance
                results = {}
                for name, model in models.items():
                    y_pred = model.predict(X_test)
                    accuracy = accuracy_score(y_test, y_pred)
                    precision = precision_score(y_test, y_pred, average='weighted')
                    recall = recall_score(y_test, y_pred, average='weighted')
                    results[name] = {'accuracy': accuracy, 'precision': precision, 'recall': recall}
                    print(f"{name} Performance:")
                    print(f"\tAccuracy: {accuracy:.4f}")
                    print(f"\tPrecision: {precision:.4f}")
                    print(f"\tRecall: {recall:.4f}")
                    print(classification_report(y_test, y_pred))  # Print detailed classification report

                # Visualize results (e.g., bar chart for accuracy)
                plt.figure(figsize=(10, 6))
                plt.bar(results.keys(), [result['accuracy'] for result in results.values()])
                plt.xlabel('Model')
                plt.ylabel('Accuracy')
                plt.title('Model Accuracy Comparison')
                plt.xticks(rotation=45)
                plt.tight_layout()
                plt.show()

                # Visualizations for precision and recall
                plt.figure(figsize=(10, 6))
                plt.bar(results.keys(), [result['precision'] for result in results.values()])
                plt.xlabel('Model')
                plt.ylabel('Precision')
                plt.title('Model Precision Comparison')
                plt.xticks(rotation=45)
                plt.tight_layout()
                plt.show()

                plt.figure(figsize=(10, 6))
                plt.bar(results.keys(), [result['recall'] for result in results.values()])
                plt.xlabel('Model')
                plt.ylabel('Recall')
                plt.title('Model Recall Comparison')
                plt.xticks(rotation=45)
                plt.tight_layout()
                plt.show()

                input_data = pd.DataFrame([test_list],
                                        columns=X.columns)

                # Standardize the input data using the same scaler
                scaled_input = scaler.transform(input_data)

                # Make predictions for each model
                predictions = {}
                for name, model in models.items():
                    prediction = model.predict(scaled_input)
                    predictions[name] = prediction

                # st.write(" ")
                # st.write("Types of models and its predictions: ")

                # # Display predicted class labels for each model
                # for name, prediction in predictions.items():
                #     print(f"{name} Prediction: {prediction}")
                #     st.write(f"{name} Prediction: {prediction}")

                # st.write(" ")




                for name, prediction in predictions.items():
                    print('\n')
                    print("Name of the model : "f'{name}')
                    print('Patient number :',input_data['person'][0])

                    print('\n')
                    st.write("Name of the model : "f'{name}')
                    st.write('Patient number :',input_data['person'][0])
                    if prediction == 0:
                        print('Healthy but weak association with stroke')
                        st.write('Healthy but weak association with stroke')
                    if prediction == 1:
                        print('Mild hypertensive retinopathy and weak association with stroke')
                        st.write('Mild hypertensive retinopathy and weak association with stroke')
                    if prediction == 2:
                        print('moderate hypertensive retinopathy and weak association with stroke')
                        st.write('moderate hypertensive retinopathy and weak association with stroke')
                    if prediction == 3:
                        print('severe hypertensive retinopathy and weak association with stroke')
                        st.write('severe hypertensive retinopathy and weak association with stroke')
                    if prediction == 4:
                        print('very severe hypertensive retinopathy and weak association with stroke')
                        st.write('very severe hypertensive retinopathy and weak association with stroke')
                    if prediction == 5:
                        print('Healthy but can be affected with cvds or stroke')
                        st.write('Healthy but can be affected with cvds or stroke')
                    if prediction == 6:
                        print('mild hypertensive retinopathy and strong association with stroke & cvds')
                        st.write('mild hypertensive retinopathy and strong association with stroke & cvds')
                    if prediction == 7:
                        print('moderate hypertensive retinopathy and strong association with stroke & cvds')
                        st.write('moderate hypertensive retinopathy and strong association with stroke & cvds')
                    if prediction == 8:
                        print('severe hypertensive retinopathy and strong association with stroke & cvds')
                        st.write('severe hypertensive retinopathy and strong association with stroke & cvds')
                    if prediction == 9:
                        print('very severe hypertensive retinopathy and strong association with stroke')
                        st.write('very severe hypertensive retinopathy and strong association with stroke')
                    st.write('\n')
                    # st.write(prediction)
            except Exception as e:
                st.error(f"Error executing code: {e}")
                # Display "Hello, World!"
                st.write()

if __name__ == "__main__":
    main()
